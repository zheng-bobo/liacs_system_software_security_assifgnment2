# 漏洞模式挖掘（Vulnerability Pattern Mining）流程文档

## 概述

本文档描述从 MoreFixes 数据库中提取和识别重复漏洞代码模式的完整流程。该流程结合多种代码表示方法和相似度特征，自动生成可用于 GitHub 搜索的漏洞模式记录。

**主程序**: `vulnerability_pattern_miner.py`

## 完整流程

### Step 1: 数据提取（Data Extraction）

从 MoreFixes 数据库中提取高质量的漏洞修复样本。

**函数**: `extract_java_vulnerable_code()`  
**位置**: `vulnerability_pattern_miner.py`

**筛选条件**:
- `fixes.score >= 65`（高质量修复样本，准确率约 95%+，可通过 `min_score` 参数调整）
- `COALESCE(file_change.diff, '') <> ''`（要求 diff 非空字符串，可通过 `require_diff` 参数控制，默认 True）
- `COALESCE(commits.merge, FALSE) = FALSE`（排除 merge commit，可通过 `exclude_merge_commits` 参数控制，默认 True）
- `file_change.code_before IS NOT NULL AND file_change.code_before <> 'None'`（要求 code_before 字段有效）
- `LOWER(file_change.programming_language) = LOWER(:lang)`（编程语言过滤，不区分大小写匹配，支持多语言，默认 Java）

**提取字段**:
- `cve_id`: CVE 编号
- `hash`: Commit hash
- `repo_url`: 仓库 URL
- `filename`: 文件名
- `code_before`: **漏洞前的代码**（pre-fix hunk，3-8 行上下文）
- `code_after`: 修复后的代码
- `diff`: 代码差异
- `score`: 修复质量分数

**输出**: `output/extract_java_vulnerable_code.csv`

---

### Step 2: 漏洞模式识别（Vulnerability Pattern Identification）

基于 source/sink/taint 分析和安全措施检查，识别漏洞模式。

**函数**: `process_cwe_based_patterns()`  
**位置**: `vulnerability_pattern_miner.py`  
**主要方法**: 
- `extract_vulnerability_pattern()` - 提取漏洞模式
- `analyze_source_sink_taint()` - 分析 source、sink 和 taint 流
- `analyze_missing_security()` - 分析缺失的安全措施

#### 2.1 获取方法级代码变更

**函数**: `get_method_changes_for_cve()`  
**位置**: `vulnerability_pattern_miner.py`

从数据库中提取指定 CVE 的方法级代码变更信息。

**提取字段**:
- `cve_id`: CVE 编号
- `file_change_id`: 文件变更 ID
- `method_change_id`: 方法变更 ID
- `method_name`: 方法名
- `signature`: 方法签名
- `before_change`: 变更前的代码
- `code_after`: 变更后的代码
- `start_line`: 起始行号
- `end_line`: 结束行号

#### 2.2 Source 识别（不可信输入源）

**函数**: `analyze_source_sink_taint()` 中的 source 模式识别

识别代码中的不可信输入源，包括：

- **Servlet API**: `getParameter()`, `getHeader()`, `getQueryString()`, `getAttribute()`, `getCookies()` 等
- **Spring Framework**: `@RequestParam`, `@PathVariable`, `@RequestHeader`, `@RequestBody`
- **文件操作**: `new File()`, `Paths.get()`
- **反序列化**: `readObject()`, `ObjectInputStream.readObject()`
- **系统属性**: `System.getenv()`, `System.getProperty()`
- **命令行参数**: `args[]`

**示例**:
```java
String urlParam = request.getParameter("url");  // Source: getParameter
String header = request.getHeader("User-Agent"); // Source: getHeader
File file = new File(userInput);                // Source: newFile
```

#### 2.3 Sink 识别（危险使用点）

**函数**: `analyze_source_sink_taint()` 中的 sink 模式识别

根据 CWE 类型识别危险使用点：

- **SQLi sinks**: `execute()`, `executeQuery()`, `executeUpdate()`, `createStatement()`
- **XSS sinks (CWE-79)**: `println()`, `print()`, `write()`, `append()`, `getWriter()`, `innerHTML`, `outerHTML`
- **Path Traversal sinks (CWE-22)**: `new File()`, `FileInputStream()`, `FileOutputStream()`, `Files.readAllBytes()`, `Paths.get()`
- **Command Injection sinks**: `Runtime.exec()`, `ProcessBuilder()`
- **Deserialization sinks**: `readObject()`, `ObjectInputStream.readObject()`

**示例**:
```java
statement.execute(sql);              // SQLi sink
response.getWriter().print(param);   // XSS sink
new File(userPath);                  // Path Traversal sink
Runtime.getRuntime().exec(cmd);      // Command Injection sink
```

#### 2.4 Taint Flow 分析

**函数**: `analyze_source_sink_taint()` 中的 taint flow 追踪

追踪数据从 source 到 sink 的传播路径：

1. 识别 source 并标记变量为 tainted（被污染）
2. 追踪 tainted 变量在代码中的使用
3. 检查 tainted 变量是否到达 sink
4. 建立 source → variable → sink 的 taint flow

**示例**:
```java
String param = request.getParameter("input");  // Source: param 被标记为 tainted
String processed = param.trim();                 // processed 也是 tainted
response.getWriter().print(processed);          // Taint flow: param → processed → sink
```

#### 2.5 安全措施分析

**函数**: `analyze_missing_security()`

对比修复前后的代码，识别缺失的安全措施：

- **PreparedStatement**: SQL 注入防护
- **escapeHtml**: XSS 防护（CWE-79）
- **normalize**: 路径规范化（CWE-22）
- **pathValidation**: 路径验证（CWE-22）
- **ObjectInputFilter**: 反序列化防护
- **validation**: 输入验证
- **whitelist**: 白名单过滤
- **sanitize**: 数据清理

**分析逻辑**:
- 检查修复前代码中是否缺少安全措施
- 检查修复后代码中是否添加了安全措施
- 如果修复前缺少且修复后添加，则标记为缺失的安全措施

**示例**:
```java
// 修复前（缺少安全措施）
response.getWriter().print(userInput);

// 修复后（添加了安全措施）
response.getWriter().print(StringEscapeUtils.escapeHtml(userInput));
// 识别结果: missing_sanitizers = ["escapeHtml"]
```

#### 2.6 模式提取与过滤

**函数**: `extract_vulnerability_pattern()`

综合 source/sink/taint 分析和安全措施检查，提取漏洞模式。

**过滤条件**（根据 CWE 类型）:
- **CWE-79 (XSS)** 和 **CWE-22 (Path Traversal)**: 需要完整的 taint flow（source + sink + taint flow）
- **NVD-CWE-noinfo**: 放宽条件，只需要 source 和 sink 即可

**输出模式字段**:
- `sources`: source 列表
- `sinks`: sink 列表
- `taint_flows`: taint 流列表
- `tainted_variables`: 被污染的变量集合
- `missing_sanitizers`: 缺失的安全措施列表
- `added_security_measures`: 新增的安全措施列表
- `pattern_summary`: 模式摘要（has_source, has_sink, has_taint_flow, missing_security）

---

### Step 3: GitHub 查询生成（Query Generation）

为每个漏洞模式生成 GitHub 搜索查询关键词。

**类**: `GitHubQueryGenerator`  
**位置**: `github_query_generator.py`  
**方法**: `generate_github_search_keywords(patterns_df, output_dir, top_n, save_file)`

#### 3.1 关键词提取

**方法**: `_generate_github_search_keywords(pattern, cwe_id)`

基于漏洞模式的 source 和 sink 信息生成搜索关键词：

**Source 关键词提取**:
- 从 `pattern["sources"]` 中提取 source 类型
- 常见 source 关键词: `getParameter`, `getHeader`, `readObject`, `new File` 等

**Sink 关键词提取**（根据 CWE 类型优化）:
- **CWE-79 (XSS)**: `println`, `response.getWriter`, `innerHTML` 等
- **CWE-22 (Path Traversal)**: `new File`, `Files.readAllBytes`, `Paths.get` 等
- **SQLi**: `execute`, `executeQuery`, `createStatement` 等
- **Command Injection**: `Runtime.exec`, `ProcessBuilder` 等

#### 3.2 查询构建

**查询格式**:
```
(source_keyword OR source_keyword) (sink_keyword OR sink_keyword) language:java
```

**示例**:
```
(getParameter OR getHeader) (println OR response.getWriter) language:java
(new File OR Paths.get) (Files.readAllBytes OR FileInputStream) language:java
```

#### 3.3 输出格式

**输出文件**: `output/recurring_patterns_top{n}.csv`

**字段**:
- `cwe_id`: CWE 编号
- `cwe_name`: CWE 名称
- `cve_id`: CVE 编号
- `file_change_id`: 文件变更 ID
- `method_change_id`: 方法变更 ID
- `method_name`: 方法名
- `sources`: source 列表（字符串格式）
- `sinks`: sink 列表（字符串格式）
- `taint_flows`: taint 流列表（字符串格式）
- `missing_sanitizers`: 缺失的安全措施列表（字符串格式）
- `github_search_keywords`: GitHub 搜索查询关键词
- `method_code`: 方法代码片段（前500字符）

---

## 完整工作流程

```
┌─────────────────────────────────────────────────────────────┐
│ Step 1: 数据提取                                            │
│ extract_java_vulnerable_code()                              │
│ - 从数据库提取高质量漏洞修复样本                            │
│ - 筛选条件: score >= 65, diff 非空, merge = FALSE,        │
│   code_before 有效, 编程语言过滤（不区分大小写）           │
│ - 可选: 筛选 top n CWE                                      │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ Step 2: 漏洞模式识别                                        │
│ process_cwe_based_patterns()                                │
│ - 获取方法级代码变更                                        │
│ - Source/Sink/Taint 分析                                    │
│ - 安全措施分析（对比修复前后）                              │
│ - 模式提取与过滤（基于 CWE 类型）                          │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ Step 3: GitHub 查询生成                                     │
│ GitHubQueryGenerator.generate_github_search_keywords()     │
│ - 从 source/sink 提取关键词                                 │
│ - 根据 CWE 类型优化查询                                     │
│ - 生成 GitHub 搜索查询字符串                                │
└─────────────────────────────────────────────────────────────┘
```

## 使用方法

### 命令行使用

```bash
# 提取前 10 个最常见的漏洞模式
python vulnerability_pattern_miner.py --top-n 10 --min-score 65 --languages java

# 支持多语言
python vulnerability_pattern_miner.py --top-n 3 --languages java javascript python

# 包含 merge commit
python vulnerability_pattern_miner.py --top-n 3 --include-merge --languages java
```

### Python API 使用

```python
from vulnerability_pattern_miner import (
    DatabaseConnector,
    extract_java_vulnerable_code,
    process_cwe_based_patterns,
)
from github_query_generator import GitHubQueryGenerator
from pathlib import Path

# 1. 连接数据库
db_connector = DatabaseConnector()

# 2. 提取漏洞代码（可选：筛选 top n CWE）
vulnerable_code_df = extract_java_vulnerable_code(
    db_connector,
    min_score=65,
    exclude_merge_commits=True,
    programming_languages=["Java"],
    require_diff=True,
    top_n=3,  # 可选：只提取 top 3 CWE 的数据
)

# 3. 识别漏洞模式（基于 CWE 的 source/sink/taint 分析）
patterns_df = process_cwe_based_patterns(
    vulnerable_code_df,
    db_connector,
    top_n=3,
    min_score=65,
    programming_languages=["Java"],
    output_dir=Path("output"),
)

# 4. 生成 GitHub 查询
if len(patterns_df) > 0:
    query_generator = GitHubQueryGenerator()
    patterns_df = query_generator.generate_github_search_keywords(
        patterns_df,
        output_dir=Path("output"),
        top_n=3,
        save_file=True,
    )
```

## 输出文件

1. **`output/extract_java_vulnerable_code.csv`**
   - 提取的漏洞代码数据
   - 包含: cve_id, hash, repo_url, filename, score, programming_language 等元数据

2. **`output/top_cwe_top{n}.csv`**
   - Top N CWE 列表
   - 包含: cwe_id, cwe_name

3. **`output/recurring_patterns_top{n}.csv`**
   - 漏洞模式记录（包含 GitHub 查询关键词）
   - 包含: cwe_id, cwe_name, cve_id, file_change_id, method_change_id, method_name, sources, sinks, taint_flows, missing_sanitizers, github_search_keywords, method_code 等字段

## 技术细节

### Source/Sink/Taint 分析流程

```
方法代码
  ↓
Source 识别（正则表达式匹配）
  - 识别不可信输入源（getParameter, getHeader 等）
  - 标记变量为 tainted（被污染）
  ↓
Sink 识别（正则表达式匹配）
  - 识别危险使用点（execute, println, new File 等）
  - 根据 CWE 类型过滤相关 sink
  ↓
Taint Flow 追踪
  - 追踪 tainted 变量在代码中的传播
  - 检查 tainted 变量是否到达 sink
  - 建立 source → variable → sink 的 taint flow
  ↓
多轮 Taint 传播分析
  - 赋值传播: x = tainted_var
  - 字符串拼接传播: sql = "SELECT" + tainted_var
  - StringBuilder 传播: sb.append(tainted_var)
```

### 安全措施分析流程

```
修复前代码 + 修复后代码
  ↓
对比分析
  - 检查修复前是否缺少安全措施
  - 检查修复后是否添加了安全措施
  ↓
识别缺失的安全措施
  - PreparedStatement（SQLi 防护）
  - escapeHtml（XSS 防护）
  - normalize（路径规范化）
  - pathValidation（路径验证）
  - 等等
```

### GitHub 查询生成流程

```
漏洞模式（包含 sources, sinks, cwe_id）
  ↓
提取 Source 关键词
  - 从 sources 列表中提取关键词
  - 常见: getParameter, getHeader, readObject 等
  ↓
提取 Sink 关键词（根据 CWE 类型）
  - CWE-79: println, response.getWriter, innerHTML
  - CWE-22: new File, Files.readAllBytes, Paths.get
  - SQLi: execute, executeQuery, createStatement
  ↓
构建查询字符串
  - 格式: (source1 OR source2) (sink1 OR sink2) language:java
```

## 性能优化

1. **CWE 筛选**: 使用 `top_n` 参数只处理最常见的 CWE 类型，减少处理量
2. **批量查询**: 一次性获取 CWE 分类信息，避免重复查询数据库
3. **正则表达式优化**: 使用编译后的正则表达式模式进行高效匹配
4. **Taint 传播限制**: 限制 taint 传播的最大迭代次数（默认 5 次），避免无限循环

## 注意事项

1. **语言支持**: 
   - 当前主要支持 Java 语言
   - Source/Sink 模式针对 Java 常见 API 优化
   - 其他语言可能需要扩展 source/sink 模式

2. **CWE 类型**: 
   - 支持特定 CWE 类型的针对性分析（CWE-79, CWE-22 等）
   - 对于 `NVD-CWE-noinfo`，放宽过滤条件（只需要 source + sink）

3. **Taint Flow 分析**: 
   - 使用正则表达式进行近似分析，可能无法捕获所有复杂的控制流
   - 多轮传播分析可能产生误报

4. **GitHub API 限制**: 
   - 需要 GitHub Personal Access Token（可选，但推荐）
   - 注意 API rate limit（未认证: 60 次/小时，认证: 5000 次/小时）

5. **数据库连接**: 
   - 需要配置数据库连接信息（通过环境变量或 `.env` 文件）

## 示例输出

### Recurring Pattern 示例

```csv
cwe_id,cwe_name,cve_id,method_name,sources,sinks,github_search_keywords
CWE-79,Cross-site Scripting (XSS),CVE-2021-xxxx,processRequest,"[{'variable': 'param', 'type': 'getParameter'}]","[{'sink_name': 'println', 'vuln_type': 'XSS'}]","(getParameter OR getHeader) (println OR response.getWriter) language:java"
CWE-22,Path Traversal,CVE-2022-yyyy,readFile,"[{'variable': 'path', 'type': 'newFile'}]","[{'sink_name': 'FileInputStream', 'vuln_type': 'PathTraversal'}]","(new File OR Paths.get) (Files.readAllBytes OR FileInputStream) language:java"
```

## 相关文件

- `vulnerability_pattern_miner.py`: 主程序文件（包含数据提取和模式识别）
- `github_query_generator.py`: GitHub 查询生成模块
- `DATABASE_TABLES_EXPLANATION.md`: 数据库表结构说明
- `README.md`: 项目总体说明
