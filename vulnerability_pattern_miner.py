"""
Vulnerability Pattern Mining Tool

Extracts vulnerable code snippets from the MoreFixes database, identifies recurring vulnerability patterns
based on CWE types, and generates GitHub search queries.

Main functionalities:
1. Data Extraction: Extracts high-quality vulnerability fix samples from the database
   - Score >= 65 (high accuracy, ~95%+)
   - Non-empty diff required
   - Excludes merge commits
   - Supports Top N CWE filtering

2. Pattern Identification: Uses source/sink/taint analysis to identify recurring vulnerability patterns
   - Source identification: Identifies untrusted input sources (e.g., getParameter, getHeader, readObject)
   - Sink identification: Identifies dangerous usage points (e.g., SQL execution, XSS output, path operations)
   - Taint flow analysis: Tracks data propagation from source to sink
   - Security measures analysis: Identifies missing security measures (e.g., HTML escaping, path normalization)
   - CWE-specific analysis: Supports targeted analysis for specific CWE types:
     * CWE-79: Cross-site Scripting (XSS)
     * CWE-22: Path Traversal
     * NVD-CWE-noinfo: Insufficient Information (uses generic patterns)

3. Query Generation: Generates GitHub search queries for each recognized pattern
   - Generates queries based on source/sink keywords
   - Optimizes keywords according to CWE types
   - Supports GitHub API integration for actual code search
   - Automatically handles GitHub API rate limits

Module structure:
- github_query_generator.py: GitHub query generation and API integration module

Usage:
    python vulnerability_pattern_miner.py --top-n 3 --min-score 65 --languages java

Command-line arguments:
    --top-n: Number of top CWE types to process (default: 3)
    --min-score: Minimum score threshold (default: 65)
    --include-merge: Include merge commits (default: excluded)
    --languages: Programming languages list, case-insensitive (default: java)

Output files:
    - output/extract_java_vulnerable_code.csv: Extracted vulnerable code samples
    - output/top_cwe_top{n}.csv: Top N CWE types list
    - output/cwe_based_patterns_top{n}.csv: Pattern records with GitHub queries
    - output/github_search_results.csv: GitHub API search results (optional)

For details, please refer to README.md
"""

import os
import sys
from pathlib import Path
from typing import Optional, List, Dict, Set, Tuple
import logging
import argparse
from dotenv import load_dotenv
import pandas as pd
import sqlalchemy
from sqlalchemy import text
import re
from collections import defaultdict
import time

# 导入拆分的模块
from github_query_generator import GitHubQueryGenerator

# 加载环境变量
load_dotenv(".env")

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("vulnerability_pattern_miner.log"),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger(__name__)


class DatabaseConnector:
    """Database connector"""

    def __init__(self):
        self.engine = None
        self._connect()

    def _connect(self):
        """Connect to the database"""
        try:
            db_url = (
                f'postgresql://{os.getenv("POSTGRES_USER")}:'
                f'{os.getenv("POSTGRES_PASSWORD")}@'
                f'{os.getenv("DB_HOST")}:{os.getenv("POSTGRES_PORT")}/'
                f'{os.getenv("POSTGRES_DB")}'
            )
            self.engine = sqlalchemy.create_engine(db_url)
            logger.info("Database connected successfully")
        except Exception as e:
            logger.error(f"Database connection failed: {e}")
            sys.exit(1)

    def execute_query(self, query: str, params: Optional[dict] = None) -> pd.DataFrame:
        """Execute query and return DataFrame"""
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text(query), params or {})
                # 使用 fetchall() 获取所有结果，对于大数据集可能需要一些时间
                rows = result.fetchall()
                df = pd.DataFrame(rows, columns=result.keys())
                return df
        except Exception as e:
            logger.error(f"Query execution failed: {e}")
            raise


def extract_java_vulnerable_code(
    db_connector: DatabaseConnector,
    min_score: int = 65,
    exclude_merge_commits: bool = True,
    programming_languages: list = None,
    require_diff: bool = True,
    top_n: int = None,
    output_dir: Path = None,
) -> pd.DataFrame:
    """
    从数据库中提取指定语言的漏洞代码，可选地筛选 top n CWE

    Args:
        db_connector: 数据库连接器
        min_score: fixes.score 的最小值，默认 65 (准确率约在 95%+)
        exclude_merge_commits: 是否排除 merge commit，默认 True
        programming_languages: 编程语言列表，默认 ['Java']
        require_diff: 是否要求 diff 非空，默认 True
        top_n: 如果指定，则只返回 top n CWE 的漏洞代码，默认 None（返回所有）
        output_dir: 输出目录，默认 None（使用当前目录下的 output 目录）

    Returns:
        包含漏洞代码信息的 DataFrame（如果指定了 top_n，则只包含 top n CWE 的数据）
    """
    if programming_languages is None:
        programming_languages = ["Java"]

    logger.info(f"开始提取 {programming_languages} 语言的漏洞代码...")
    logger.info(
        f"筛选条件: min_score={min_score}, exclude_merge={exclude_merge_commits}, "
        f"require_diff={require_diff}"
    )

    # 构建语言过滤条件（不区分大小写匹配）
    # 允许传入 "java"、"JAVA"、"Java" 等不同大小写的值，都能匹配到数据库中的记录
    lang_conditions = []
    for i, lang in enumerate(programming_languages):
        # 使用 LOWER() 函数进行不区分大小写匹配，使用参数化查询避免 SQL 注入
        lang_conditions.append(f"LOWER(fc.programming_language) = LOWER(:lang_{i})")

    # 准备参数
    params = {"min_score": min_score}
    for i, lang in enumerate(programming_languages):
        params[f"lang_{i}"] = lang

    lang_filter = " OR ".join(lang_conditions)

    # 构建 WHERE 条件
    where_conditions = []

    # diff 条件
    if require_diff:
        where_conditions.append("COALESCE(fc.diff, '') <> ''")

    # merge commit 条件
    if exclude_merge_commits:
        where_conditions.append("COALESCE(c.merge, FALSE) = FALSE")

    # code_before 条件：过滤掉 None 字符串和 NULL 值
    where_conditions.append("fc.code_before IS NOT NULL AND fc.code_before <> 'None'")

    # 编程语言条件（不区分大小写）
    where_conditions.append(f"({lang_filter})")

    where_clause = " AND ".join(where_conditions)

    query = f"""
    -- 取"可用于模式挖掘"的高质量修复样本
    WITH good_fixes AS (
      SELECT f.cve_id, f.hash, f.repo_url, f.score
      FROM fixes f
      WHERE f.score >= :min_score
    )
    SELECT
      gf.cve_id,
      gf.repo_url,
      gf.hash,
      gf.score,
      c.author_date,
      c.msg,
      fc.file_change_id,
      fc.filename,
      fc.programming_language,
      fc.code_before,
      fc.code_after,
      fc.diff
    FROM good_fixes gf
    JOIN commits c
      ON c.hash = gf.hash AND c.repo_url = gf.repo_url
    JOIN file_change fc
      ON fc.hash = gf.hash
    WHERE {where_clause};
    """

    logger.info("正在执行数据库查询，这可能需要一些时间...")
    start_time = time.time()
    df = db_connector.execute_query(query, params=params)
    elapsed_time = time.time() - start_time
    logger.info(f"数据库查询完成，耗时: {elapsed_time:.2f} 秒")

    if df.empty:
        logger.warning("未提取到任何漏洞代码记录")
        return df

    logger.info(f"提取了 {len(df)} 条漏洞代码记录")
    logger.info(f"涉及 {df['cve_id'].nunique()} 个 CVE")
    logger.info(f"涉及 {df['hash'].nunique()} 个 commit")
    logger.info(f"涉及 {df['repo_url'].nunique()} 个仓库")

    # 如果指定了 top_n，则筛选 top n CWE 的数据
    if top_n is not None and top_n > 0:
        logger.info(f"\n筛选 top {top_n} CWE 的漏洞代码...")

        # 获取 CWE 分类信息
        cwe_classification_df = _get_cwe_classification(df, db_connector)
        if cwe_classification_df.empty:
            logger.warning("未找到 CWE 分类信息，返回所有数据")
            return df

        # 统计每个 CWE 的 CVE 数量，选出 top n
        cwe_counts = (
            cwe_classification_df[cwe_classification_df["cve_id"].isin(df["cve_id"])]
            .groupby(["cwe_id", "cwe_name"])
            .size()
            .reset_index(name="fix_count")
            .query("fix_count > 1")
            .sort_values("fix_count", ascending=False)
            .head(top_n)
        )

        if cwe_counts.empty:
            logger.warning("未找到符合条件的 CWE，返回所有数据")
            return df

        logger.info(f"找到 {len(cwe_counts)} 个 top CWE:")
        for _, row in cwe_counts.iterrows():
            logger.info(
                f"  {row['cwe_id']}: {row['cwe_name']} (fix_count: {row['fix_count']})"
            )

        # 获取 top n CWE 的 CVE 列表
        top_cwe_ids = cwe_counts["cwe_id"].tolist()
        top_cwe_cves = cwe_classification_df[
            cwe_classification_df["cwe_id"].isin(top_cwe_ids)
        ]["cve_id"].unique()

        # 过滤 df，只保留属于 top n CWE 的记录
        original_count = len(df)
        df = df[df["cve_id"].isin(top_cwe_cves)]
        filtered_count = len(df)

        logger.info(
            f"筛选完成：从 {original_count} 条记录筛选到 {filtered_count} 条记录 "
            f"（属于 top {top_n} CWE）"
        )
        logger.info(f"涉及 {df['cve_id'].nunique()} 个 CVE")
        logger.info(f"涉及 {df['hash'].nunique()} 个 commit")

    # 保存原始数据（排除 code_before 和 code_after 列，但包含 score 列）
    if output_dir is None:
        output_dir = Path("output")
    output_dir.mkdir(exist_ok=True)

    # 准备要保存的列：排除 code_before 和 code_after
    columns_to_save = [
        col for col in df.columns if col not in ["code_before", "code_after"]
    ]
    output_df = df[columns_to_save].copy()

    output_file = output_dir / "extract_java_vulnerable_code.csv"
    output_df.to_csv(output_file, index=False, encoding="utf-8")
    logger.info(f"原始数据已保存到: {output_file}")

    return df


def _get_cwe_classification(
    vulnerable_code_df: pd.DataFrame, db_connector: DatabaseConnector
) -> pd.DataFrame:
    """获取 vulnerable_code_df 中所有 CVE 的 CWE 分类信息"""
    if vulnerable_code_df.empty or "cve_id" not in vulnerable_code_df.columns:
        return pd.DataFrame()

    unique_cves = vulnerable_code_df["cve_id"].unique()
    if len(unique_cves) == 0:
        return pd.DataFrame()

    placeholders = ", ".join([f":cve_{i}" for i in range(len(unique_cves))])
    params = {f"cve_{i}": cve_id for i, cve_id in enumerate(unique_cves)}

    query = f"""
    SELECT cc.cve_id, cc.cwe_id, c.cwe_name
    FROM cwe_classification cc
    JOIN cwe c ON cc.cwe_id = c.cwe_id
    WHERE cc.cve_id IN ({placeholders});
    """
    return db_connector.execute_query(query, params=params)


def get_top_cwe_by_frequency_from_df(
    vulnerable_code_df: pd.DataFrame,
    db_connector: DatabaseConnector,
    top_n: int = 3,
) -> pd.DataFrame:
    """基于 vulnerable_code_df 按 CWE 统计频率，选出出现次数 top n 的 CWE"""
    logger.info(
        f"\n步骤2.1: 基于 vulnerable_code_df 按 CWE 统计频率，选出 top {top_n} 的 CWE"
    )

    cwe_df = _get_cwe_classification(vulnerable_code_df, db_connector)
    if cwe_df.empty:
        logger.warning("未找到 CWE 分类信息")
        return pd.DataFrame()

    # 统计每个 CWE 的 CVE 数量
    cwe_counts = (
        cwe_df[cwe_df["cve_id"].isin(vulnerable_code_df["cve_id"])]
        .groupby(["cwe_id", "cwe_name"])
        .size()
        .reset_index(name="fix_count")
        .query("fix_count > 1")
        .sort_values("fix_count", ascending=False)
        .head(top_n)
    )

    logger.info(f"找到 {len(cwe_counts)} 个 top CWE:")
    for _, row in cwe_counts.iterrows():
        logger.info(
            f"  {row['cwe_id']}: {row['cwe_name']} (fix_count: {row['fix_count']})"
        )

    return cwe_counts[["cwe_id", "cwe_name", "fix_count"]]


def get_cves_by_cwe_from_df(
    vulnerable_code_df: pd.DataFrame,
    cwe_id: str,
    cwe_classification_df: pd.DataFrame,
) -> pd.DataFrame:
    """从 vulnerable_code_df 中选出指定 CWE 的 CVE"""
    logger.info(f"\n步骤2.3: 从 vulnerable_code_df 中选出 {cwe_id} 的 CVE")

    # 从已有的 CWE 分类中筛选
    cwe_cves = cwe_classification_df[cwe_classification_df["cwe_id"] == cwe_id][
        "cve_id"
    ]
    if cwe_cves.empty:
        logger.warning(f"未找到 CWE {cwe_id} 的 CVE")
        return pd.DataFrame()

    # 统计 vulnerable_code_df 中每个 CVE 的出现次数
    cve_counts = (
        vulnerable_code_df[vulnerable_code_df["cve_id"].isin(cwe_cves)]
        .groupby("cve_id")
        .size()
        .reset_index(name="fix_count")
        .sort_values("fix_count", ascending=False)
    )

    logger.info(f"找到 {len(cve_counts)} 个 CVE")
    return cve_counts


def get_method_changes_for_cve(
    db_connector: DatabaseConnector,
    cve_id: str,
    min_score: int = 65,
    programming_languages: List[str] = None,
) -> pd.DataFrame:
    """
    步骤2.3: 获取指定 CVE 的方法级代码变更

    Args:
        db_connector: 数据库连接器
        cve_id: CVE 编号
        min_score: fixes.score 的最小值，默认 65
        programming_languages: 编程语言列表，默认 ['Java']

    Returns:
        包含方法变更信息的 DataFrame，包含以下字段：
        - cve_id: CVE 编号
        - file_change_id: 文件变更 ID
        - method_change_id: 方法变更 ID
        - method_name: 方法名
        - signature: 方法签名
        - before_change: 变更前的代码
        - code: 变更后的代码
        - start_line: 起始行号
        - end_line: 结束行号
    """
    if programming_languages is None:
        programming_languages = ["Java"]

    logger.info(f"\n步骤2.3: 获取 {cve_id} 的方法级代码变更")

    # 构建语言过滤条件
    lang_conditions = []
    params = {"min_score": min_score, "cve_id": cve_id}
    for i, lang in enumerate(programming_languages):
        lang_conditions.append(f"LOWER(fc.programming_language) = LOWER(:lang_{i})")
        params[f"lang_{i}"] = lang

    lang_filter = " OR ".join(lang_conditions)

    query = f"""
    SELECT DISTINCT
      f.cve_id,
      fc.file_change_id,
      mc.method_change_id,
      mc.name as method_name,
      mc.signature,
      mc.before_change,
      mc.code as code_after,
      mc.start_line,
      mc.end_line,
      fc.code_before as file_code_before,
      fc.code_after as file_code_after
    FROM fixes f
    JOIN file_change fc ON fc.hash = f.hash
    JOIN method_change mc ON mc.file_change_id = fc.file_change_id
    WHERE f.cve_id = :cve_id
      AND f.score >= :min_score
      AND ({lang_filter})
      AND mc.before_change IS NOT NULL
      AND mc.before_change <> ''
      AND mc.before_change <> 'None'
    ORDER BY fc.file_change_id, mc.start_line;
    """

    df = db_connector.execute_query(query, params=params)

    # logger.info(f"找到 {len(df)} 个方法变更记录")

    return df


def analyze_source_sink_taint(
    code: str,
    language: str = "java",
    cwe_id: str = None,
) -> Dict:
    """
    步骤2.4: 分析代码中的 source、sink、taint 流（针对 Java 优化）

    Args:
        code: 要分析的代码
        language: 编程语言，默认 'java'
        cwe_id: CWE 编号，用于过滤相关的 sink 模式，默认 None（不过滤）

    Returns:
        包含分析结果的字典：
        - sources: 找到的 source 列表
        - sinks: 找到的 sink 列表
        - taint_flows: taint 流列表
        - tainted_variables: 被污染的变量集合
    """
    # 检查 code 是否为空
    if not code or not isinstance(code, str) or code.strip() == "":
        return {
            "sources": [],
            "sinks": [],
            "taint_flows": [],
            "tainted_variables": [],
        }

    if language.lower() != "java":
        logger.warning(f"当前仅支持 Java 语言分析，跳过 {language}")
        return {
            "sources": [],
            "sinks": [],
            "taint_flows": [],
            "tainted_variables": [],
        }

    sources = []
    sinks = []
    tainted_variables = set()
    taint_flows = []

    # Java Source 模式（不可信输入）- 扩展更多常见模式
    source_patterns = [
        # Servlet API
        (r"(\w+)\s*=\s*request\.getParameter\s*\(", "getParameter"),
        (r"(\w+)\s*=\s*request\.getHeader\s*\(", "getHeader"),
        (r"(\w+)\s*=\s*request\.getQueryString\s*\(", "getQueryString"),
        (r"(\w+)\s*=\s*request\.getAttribute\s*\(", "getAttribute"),
        (r"(\w+)\s*=\s*request\.getCookies\s*\(", "getCookies"),
        (r"(\w+)\s*=\s*request\.getParameterValues\s*\(", "getParameterValues"),
        (r"(\w+)\s*=\s*request\.getParameterMap\s*\(", "getParameterMap"),
        (r"(\w+)\s*=\s*request\.getPathInfo\s*\(", "getPathInfo"),
        (r"(\w+)\s*=\s*request\.getRequestURI\s*\(", "getRequestURI"),
        # Spring Framework
        (r"(\w+)\s*=\s*@RequestParam\s*", "RequestParam"),
        (r"(\w+)\s*=\s*@PathVariable\s*", "PathVariable"),
        (r"(\w+)\s*=\s*@RequestHeader\s*", "RequestHeader"),
        (r"(\w+)\s*=\s*@RequestBody\s*", "RequestBody"),
        # 文件操作
        (r"(\w+)\s*=\s*new\s+File\s*\([^)]*(\w+)[^)]*\)", "newFile"),
        (r"(\w+)\s*=\s*Paths\.get\s*\(", "Paths.get"),
        # 反序列化
        (r"(\w+)\s*=\s*.*\.readObject\s*\(", "readObject"),
        (r"(\w+)\s*=\s*ObjectInputStream.*\.readObject\s*\(", "readObject"),
        # 系统属性/环境变量
        (r"(\w+)\s*=\s*System\.getenv\s*\(", "getenv"),
        (r"(\w+)\s*=\s*System\.getProperty\s*\(", "getProperty"),
        # 其他常见输入
        (r"(\w+)\s*=\s*args\s*\[", "args"),
        (r"(\w+)\s*=\s*\.get\s*\(", "get"),
    ]

    # Java Sink 模式（危险使用点）- 按漏洞类型分类
    sink_patterns = [
        # SQLi sinks
        (r"\.execute\s*\(", "SQLi", "execute"),
        (r"\.executeQuery\s*\(", "SQLi", "executeQuery"),
        (r"\.executeUpdate\s*\(", "SQLi", "executeUpdate"),
        (r"Statement\s*.*\.execute", "SQLi", "Statement.execute"),
        (r"createStatement\s*\(\)", "SQLi", "createStatement"),
        # XSS sinks (CWE-79)
        (r"\.println\s*\(", "XSS", "println"),
        (r"\.print\s*\(", "XSS", "print"),
        (r"\.write\s*\(", "XSS", "write"),
        (r"\.append\s*\(", "XSS", "append"),
        (r"response\.getWriter\s*\(\)\.", "XSS", "getWriter"),
        (r"out\.print", "XSS", "out.print"),
        (r"PrintWriter.*\.print", "XSS", "PrintWriter.print"),
        (r"response\.setContentType\s*\(", "XSS", "setContentType"),
        (r"document\.write\s*\(", "XSS", "document.write"),
        (r"innerHTML\s*=", "XSS", "innerHTML"),
        (r"outerHTML\s*=", "XSS", "outerHTML"),
        (r"\.html\s*\(", "XSS", "html"),
        # 路径穿越 sinks (CWE-22)
        (r"new\s+File\s*\(", "PathTraversal", "new File"),
        (r"FileInputStream\s*\(", "PathTraversal", "FileInputStream"),
        (r"FileOutputStream\s*\(", "PathTraversal", "FileOutputStream"),
        (r"Files\.readAllBytes\s*\(", "PathTraversal", "Files.readAllBytes"),
        (r"Files\.readString\s*\(", "PathTraversal", "Files.readString"),
        (r"Files\.copy\s*\(", "PathTraversal", "Files.copy"),
        (r"Files\.move\s*\(", "PathTraversal", "Files.move"),
        (r"Files\.write\s*\(", "PathTraversal", "Files.write"),
        (r"\.getCanonicalPath\s*\(", "PathTraversal", "getCanonicalPath"),
        (r"\.toPath\s*\(", "PathTraversal", "toPath"),
        (r"Paths\.get\s*\(", "PathTraversal", "Paths.get"),
        (r"\.getAbsolutePath\s*\(", "PathTraversal", "getAbsolutePath"),
        (r"\.getAbsoluteFile\s*\(", "PathTraversal", "getAbsoluteFile"),
        # 命令注入 sinks
        (r"Runtime\.getRuntime\s*\(\)\.exec\s*\(", "CommandInjection", "Runtime.exec"),
        (r"ProcessBuilder\s*\(", "CommandInjection", "ProcessBuilder"),
        # 反序列化 sinks
        (r"\.readObject\s*\(", "Deserialization", "readObject"),
        (
            r"ObjectInputStream.*\.readObject",
            "Deserialization",
            "ObjectInputStream.readObject",
        ),
    ]

    # 查找 sources
    for pattern_tuple in source_patterns:
        pattern, source_type = (
            pattern_tuple
            if isinstance(pattern_tuple, tuple)
            else (pattern_tuple, "unknown")
        )
        matches = re.finditer(pattern, code, re.IGNORECASE | re.MULTILINE)
        for match in matches:
            var_name = match.group(1) if match.groups() else None
            if var_name and var_name not in ["null", "true", "false"]:  # 排除关键字
                sources.append(
                    {
                        "variable": var_name,
                        "pattern": pattern,
                        "type": source_type,
                    }
                )
                tainted_variables.add(var_name)

    # 查找 sinks 并建立 taint flow
    for pattern_tuple in sink_patterns:
        pattern, vuln_type, sink_name = pattern_tuple
        matches = re.finditer(pattern, code, re.IGNORECASE | re.MULTILINE)
        for match in matches:
            start_pos = match.start()
            # 获取匹配行的上下文（前后各2行）
            line_start = code.rfind("\n", 0, start_pos) + 1
            line_end = code.find("\n", start_pos)
            if line_end == -1:
                line_end = len(code)
            line = code[line_start:line_end]

            # 检查这一行及前后行中是否有 tainted 变量
            context_start = max(0, code.rfind("\n", 0, line_start - 1))
            context_end = min(len(code), code.find("\n", line_end + 1))
            context = code[context_start:context_end]

            # 检查是否有 tainted 变量在 sink 附近
            for tainted_var in tainted_variables:
                # 检查变量是否在 sink 之前被使用
                var_positions = [
                    m.start()
                    for m in re.finditer(
                        rf"\b{re.escape(tainted_var)}\b", context, re.IGNORECASE
                    )
                ]
                if var_positions and any(
                    pos < start_pos - context_start for pos in var_positions
                ):
                    sinks.append(
                        {
                            "pattern": pattern,
                            "sink_name": sink_name,
                            "vuln_type": vuln_type,
                            "line": line.strip(),
                            "type": "sink",
                        }
                    )
                    taint_flows.append(
                        {
                            "source": tainted_var,
                            "sink": sink_name,
                            "vuln_type": vuln_type,
                            "line": line.strip(),
                        }
                    )
                    break

    # 增强的 taint 传播分析：查找赋值、拼接、方法调用等
    # 例如：x = tainted_var; 或 sql = "SELECT * FROM " + tainted_var; 或 result = process(tainted_var);
    if tainted_variables:
        # 多轮迭代传播，直到没有新的 tainted 变量
        max_iterations = 5
        for iteration in range(max_iterations):
            new_tainted = set()
            escaped_vars = [re.escape(var) for var in tainted_variables]
            var_pattern = "|".join(escaped_vars)

            # 赋值传播：x = tainted_var
            assignment_pattern = rf"(\w+)\s*=\s*({var_pattern})\s*[;,\)]"
            for match in re.finditer(assignment_pattern, code, re.IGNORECASE):
                new_var = match.group(1)
                if (
                    new_var
                    and new_var not in tainted_variables
                    and new_var not in ["null", "true", "false"]
                ):
                    new_tainted.add(new_var)

            # 字符串拼接传播：sql = "SELECT" + tainted_var 或 sql = tainted_var + "FROM"
            concat_patterns = [
                rf'(\w+)\s*=\s*"[^"]*"\s*\+\s*({var_pattern})',
                rf"(\w+)\s*=\s*({var_pattern})\s*\+\s*\"[^\"]*\"",
                rf"(\w+)\s*=\s*({var_pattern})\s*\+\s*({var_pattern})",  # 两个 tainted 变量拼接
            ]
            for pattern in concat_patterns:
                try:
                    for match in re.finditer(pattern, code, re.IGNORECASE):
                        new_var = match.group(1)
                        if new_var and new_var not in tainted_variables:
                            new_tainted.add(new_var)
                except re.error:
                    continue

            # StringBuilder/StringBuffer 传播
            stringbuilder_patterns = [
                rf"(\w+)\.append\s*\(\s*({var_pattern})\s*\)",
                rf"(\w+)\s*=\s*new\s+StringBuilder\s*\(\s*({var_pattern})\s*\)",
            ]
            for pattern in stringbuilder_patterns:
                try:
                    for match in re.finditer(pattern, code, re.IGNORECASE):
                        new_var = match.group(1)
                        if new_var and new_var not in tainted_variables:
                            new_tainted.add(new_var)
                except re.error:
                    continue

            if not new_tainted:
                break
            tainted_variables.update(new_tainted)

    return {
        "sources": sources,
        "sinks": sinks,
        "taint_flows": taint_flows,
        "tainted_variables": list(tainted_variables),
    }


def analyze_missing_security(
    before_code: str,
    after_code: str,
    language: str = "java",
    cwe_id: str = None,
) -> Dict:
    """
    步骤2.5: 分析缺失的安全措施（对比 before 和 after）

    Args:
        before_code: 修复前的代码
        after_code: 修复后的代码
        language: 编程语言，默认 'java'
        cwe_id: CWE 编号，用于检查相关的安全措施，默认 None（检查所有）

    Returns:
        包含缺失安全措施的字典：
        - missing_sanitizers: 缺失的 sanitizer 列表
        - added_security_measures: 新增的安全措施列表
    """
    # 检查输入是否有效
    if not before_code or not isinstance(before_code, str):
        before_code = ""
    if not after_code or not isinstance(after_code, str):
        after_code = ""

    if language.lower() != "java":
        logger.warning(f"当前仅支持 Java 语言分析，跳过 {language}")
        return {
            "missing_sanitizers": [],
            "added_security_measures": [],
        }

    # Java 常见的安全措施（sanitizers）- 扩展更多模式
    security_patterns = {
        "PreparedStatement": [
            r"PreparedStatement",
            r"prepareStatement\s*\(",
            r"\.setString\s*\(",
            r"\.setInt\s*\(",
            r"\.setLong\s*\(",
            r"\.setBoolean\s*\(",
            r"\.setObject\s*\(",
        ],
        "escapeHtml": [  # CWE-79 (XSS) 相关
            r"escapeHtml\s*\(",
            r"StringEscapeUtils\.escapeHtml",
            r"Encode\.forHtml",
            r"ESAPI\.encoder\s*\(\)\.encodeForHTML",
            r"HtmlUtils\.htmlEscape",
            r"OWASP\.ESAPI\.encoder\(\)\.encodeForHTML",
            r"\.escapeHtml",
            r"HtmlEscape",
            r"XSSUtils\.escape",
        ],
        "normalize": [  # CWE-22 (Path Traversal) 相关
            r"Paths\.normalize\s*\(",
            r"\.toRealPath\s*\(",
            r"\.getCanonicalPath\s*\(",
            r"\.getCanonicalFile\s*\(",
            r"\.toPath\s*\(\)\.normalize",
            r"\.normalize\s*\(",
        ],
        "pathValidation": [  # CWE-22 (Path Traversal) 相关
            r"\.startsWith\s*\(",
            r"\.contains\s*\(",
            r"\.equals\s*\(",
            r"\.indexOf\s*\(",
            r"\.matches\s*\(",
            r"PathValidator",
            r"isValidPath",
            r"isAllowedPath",
        ],
        "ObjectInputFilter": [
            r"ObjectInputFilter",
            r"\.setObjectInputFilter\s*\(",
            r"ObjectInputFilter\.Config\.createFilter",
        ],
        "validation": [
            r"Pattern\.compile",
            r"\.matches\s*\(",
            r"StringUtils\.isNotBlank",
            r"StringUtils\.isNotEmpty",
            r"Validator\.validate",
            r"@Valid\s+",
            r"@NotNull\s+",
            r"@NotBlank\s+",
        ],
        "whitelist": [
            r"whitelist",
            r"allowlist",
            r"isAllowed",
            r"isWhitelisted",
        ],
        "sanitize": [
            r"sanitize\s*\(",
            r"Sanitizer\.",
            r"clean\s*\(",
        ],
    }

    missing_sanitizers = []
    added_security_measures = []

    # 检查 before_code 中缺少哪些安全措施
    for measure_name, patterns in security_patterns.items():
        found_in_before = False
        found_in_after = False

        for pattern in patterns:
            if re.search(pattern, before_code, re.IGNORECASE):
                found_in_before = True
                break
            if re.search(pattern, after_code, re.IGNORECASE):
                found_in_after = True

        if not found_in_before and found_in_after:
            missing_sanitizers.append(measure_name)
            added_security_measures.append(measure_name)

    return {
        "missing_sanitizers": missing_sanitizers,
        "added_security_measures": added_security_measures,
    }


def extract_vulnerability_pattern(
    method_code: str,
    file_code_before: str,
    file_code_after: str,
    language: str = "java",
    cwe_id: str = None,
) -> Dict:
    """
    步骤2.6: 提取漏洞模式（source/sink/taint/missing security）

    Args:
        method_code: 方法级代码（before_change）
        file_code_before: 文件级修复前代码
        file_code_after: 文件级修复后代码
        language: 编程语言，默认 'java'
        cwe_id: CWE 编号，用于针对性地分析特定类型的漏洞，支持：
                - CWE-79: Cross-site Scripting (XSS)
                - CWE-22: Path Traversal
                - NVD-CWE-noinfo: Insufficient Information（使用通用模式）
                默认 None（使用通用模式）

    Returns:
        包含漏洞模式的字典：
        - sources: source 列表
        - sinks: sink 列表
        - taint_flows: taint 流列表
        - missing_sanitizers: 缺失的 sanitizer 列表
        - pattern_summary: 模式摘要
    """
    # 检查 method_code 是否有效
    if not method_code or not isinstance(method_code, str) or method_code.strip() == "":
        # 返回空模式
        return {
            "sources": [],
            "sinks": [],
            "taint_flows": [],
            "tainted_variables": [],
            "missing_sanitizers": [],
            "added_security_measures": [],
            "pattern_summary": {
                "has_source": False,
                "has_sink": False,
                "has_taint_flow": False,
                "missing_security": False,
            },
        }

    # 分析 source/sink/taint（根据 CWE 类型过滤）
    taint_analysis = analyze_source_sink_taint(method_code, language, cwe_id)

    # 分析缺失的安全措施（根据 CWE 类型检查相关措施）
    security_analysis = analyze_missing_security(
        file_code_before if file_code_before else method_code,
        file_code_after if file_code_after else "",
        language,
        cwe_id,
    )

    # 生成模式摘要
    pattern_summary = {
        "has_source": len(taint_analysis["sources"]) > 0,
        "has_sink": len(taint_analysis["sinks"]) > 0,
        "has_taint_flow": len(taint_analysis["taint_flows"]) > 0,
        "missing_security": len(security_analysis["missing_sanitizers"]) > 0,
    }

    return {
        "sources": taint_analysis["sources"],
        "sinks": taint_analysis["sinks"],
        "taint_flows": taint_analysis["taint_flows"],
        "tainted_variables": taint_analysis["tainted_variables"],
        "missing_sanitizers": security_analysis["missing_sanitizers"],
        "added_security_measures": security_analysis["added_security_measures"],
        "pattern_summary": pattern_summary,
    }


def process_cwe_based_patterns(
    vulnerable_code_df: pd.DataFrame,
    db_connector: DatabaseConnector,
    top_n: int = 3,
    min_score: int = 65,
    programming_languages: List[str] = None,
    output_dir: Path = None,
) -> pd.DataFrame:
    """
    新的模式识别逻辑：基于 vulnerable_code_df 的 CWE 频率统计和 source/sink/taint 分析

    Args:
        vulnerable_code_df: 包含漏洞代码的 DataFrame（必须包含 cve_id 列）
                           注意：如果该 DataFrame 已经通过 extract_java_vulnerable_code
                           的 top_n 参数筛选过，则只包含 top n CWE 的数据
        db_connector: 数据库连接器
        top_n: 返回前 n 个最常见的 CWE，默认 3
               （如果 vulnerable_code_df 已经筛选过，则基于已筛选的数据计算）
        min_score: fixes.score 的最小值，默认 65（用于查询方法变更）
        programming_languages: 编程语言列表，默认 ['Java']
        output_dir: 输出目录，默认 None（使用当前目录下的 output 目录）

    Returns:
        包含模式记录的 DataFrame
    """
    if programming_languages is None:
        programming_languages = ["Java"]

    if output_dir is None:
        output_dir = Path("output")
    output_dir.mkdir(exist_ok=True)

    logger.info("\n" + "=" * 60)
    logger.info("开始基于 CWE 的模式识别（基于 vulnerable_code_df）")
    logger.info("=" * 60)

    # 检查输入 DataFrame 是否为空
    if vulnerable_code_df.empty:
        logger.warning("vulnerable_code_df 为空，无法进行模式识别")
        return pd.DataFrame()

    # 检查必需的列是否存在
    if "cve_id" not in vulnerable_code_df.columns:
        logger.error("vulnerable_code_df 缺少 'cve_id' 列")
        return pd.DataFrame()

    # 步骤2.1: 获取 CWE 分类信息（一次性获取，避免重复查询）
    cwe_classification_df = _get_cwe_classification(vulnerable_code_df, db_connector)
    if cwe_classification_df.empty:
        logger.warning("未找到 CWE 分类信息")
        return pd.DataFrame()

    # 步骤2.2: 从 vulnerable_code_df 中获取所有 CWE（vulnerable_code_df 已经包含 top n CWE 的数据）
    # 统计每个 CWE 的 CVE 数量，用于日志输出
    top_cwe_df = (
        cwe_classification_df[
            cwe_classification_df["cve_id"].isin(vulnerable_code_df["cve_id"])
        ]
        .groupby(["cwe_id", "cwe_name"])
        .size()
        .reset_index(name="fix_count")
        .query("fix_count > 1")
        .sort_values("fix_count", ascending=False)
    )

    if top_cwe_df.empty:
        logger.warning("未找到符合条件的 CWE")
        return pd.DataFrame()

    logger.info(f"找到 {len(top_cwe_df)} 个 CWE（来自已筛选的 vulnerable_code_df）:")
    for _, row in top_cwe_df.iterrows():
        logger.info(
            f"  {row['cwe_id']}: {row['cwe_name']} (fix_count: {row['fix_count']})"
        )

    # 输出 top_cwe_df 的 cwe_id 和 cwe_name 到文件
    top_cwe_output_file = output_dir / f"top_cwe_top{top_n}.csv"
    top_cwe_df[["cwe_id", "cwe_name"]].to_csv(
        top_cwe_output_file, index=False, encoding="utf-8"
    )
    logger.info(f"Top CWE 列表已保存到: {top_cwe_output_file}")

    all_patterns = []
    if not programming_languages or len(programming_languages) == 0:
        logger.error("programming_languages 列表为空")
        return pd.DataFrame()
    language = programming_languages[0].lower()

    # 对每个 CWE 进行处理
    for _, cwe_row in top_cwe_df.iterrows():
        cwe_id, cwe_name = cwe_row["cwe_id"], cwe_row["cwe_name"]
        logger.info(f"\n处理 CWE: {cwe_id} - {cwe_name}")

        # 步骤2.3: 从 vulnerable_code_df 中获取该 CWE 下的 CVE
        cve_df = get_cves_by_cwe_from_df(
            vulnerable_code_df, cwe_id, cwe_classification_df
        )

        if cve_df.empty:
            logger.warning(f"CWE {cwe_id} 下没有符合条件的 CVE")
            continue

        # 对每个 CVE 进行处理
        for cve_id in cve_df["cve_id"]:
            logger.info(f"  处理 CVE: {cve_id}")

            # 步骤2.4: 获取该 CVE 的方法级代码变更
            method_changes_df = get_method_changes_for_cve(
                db_connector, cve_id, min_score, programming_languages
            )

            if method_changes_df.empty:
                logger.warning(f"  CVE {cve_id} 没有方法级变更记录")
                continue

            # 对每个方法变更进行分析
            for _, method_row in method_changes_df.iterrows():
                method_code = method_row["before_change"]
                if not method_code or method_code == "None":
                    continue

                # 步骤2.5-2.6: 提取漏洞模式（传入 CWE ID）
                pattern = extract_vulnerability_pattern(
                    method_code,
                    method_row.get("file_code_before", ""),
                    method_row.get("file_code_after", ""),
                    language,
                    cwe_id,  # 传入 CWE ID 以支持特定类型的漏洞分析
                )

                # 根据 CWE 类型调整过滤条件
                summary = pattern["pattern_summary"]

                # CWE-79 (XSS) 和 CWE-22 (Path Traversal): 需要 source、sink 和 taint flow
                # NVD-CWE-noinfo: 放宽条件，只要有 source 和 sink 即可（因为信息不足）
                if cwe_id == "NVD-CWE-noinfo":
                    # 对于信息不足的 CWE，放宽条件：只要有 source 和 sink 即可
                    if not (summary["has_source"] and summary["has_sink"]):
                        continue
                else:
                    # 对于明确的 CWE 类型，需要完整的 taint flow
                    if not (
                        summary["has_source"]
                        and summary["has_sink"]
                        and summary["has_taint_flow"]
                    ):
                        continue

                all_patterns.append(
                    {
                        "cwe_id": cwe_id,
                        "cwe_name": cwe_name,
                        "cve_id": cve_id,
                        "file_change_id": method_row["file_change_id"],
                        "method_change_id": method_row["method_change_id"],
                        "method_name": method_row["method_name"],
                        "signature": method_row["signature"],
                        "sources": str(pattern["sources"]),
                        "sinks": str(pattern["sinks"]),
                        "taint_flows": str(pattern["taint_flows"]),
                        "tainted_variables": str(pattern["tainted_variables"]),
                        "missing_sanitizers": str(pattern["missing_sanitizers"]),
                        "added_security_measures": str(
                            pattern["added_security_measures"]
                        ),
                        "pattern_dict": pattern,  # 保存 pattern 字典用于后续生成 GitHub 查询
                        "method_code": method_code[:500],
                    }
                )

    if not all_patterns:
        logger.warning("未找到符合条件的漏洞模式")
        return pd.DataFrame()

    patterns_df = pd.DataFrame(all_patterns)
    logger.info(f"总共找到 {len(patterns_df)} 个漏洞模式")
    # 注意：不在这里保存文件，等待步骤3生成 github_query 后再保存

    return patterns_df


def main(
    top_n: int = 3,
    min_score: int = 65,
    exclude_merge_commits: bool = True,
    programming_languages: List[str] = None,
    require_diff: bool = True,
):
    """
    主函数：提取候选重复漏洞代码模式

    Args:
        top_n: 返回出现次数最多的前 n 个模式，默认 3
        min_score: fixes.score 的最小值，默认 65
        exclude_merge_commits: 是否排除 merge commit，默认 True
        programming_languages: 编程语言列表，默认 ['Java']
        require_diff: 是否要求 diff 非空，默认 True
    """
    if programming_languages is None:
        programming_languages = ["Java"]

    logger.info("=" * 60)
    logger.info("开始提取候选重复漏洞代码模式")
    logger.info(f"配置: top_n={top_n}, min_score={min_score}")
    logger.info("=" * 60)

    # 设置输出目录
    output_dir = Path("output")
    output_dir.mkdir(exist_ok=True)

    # 初始化数据库连接
    db_connector = DatabaseConnector()

    # 步骤1: 根据条件筛选漏洞代码（包含 top n CWE 筛选）
    logger.info("\n步骤1: 提取漏洞代码（包含 top n CWE 筛选）")
    vulnerable_code_df = extract_java_vulnerable_code(
        db_connector,
        min_score=min_score,
        exclude_merge_commits=exclude_merge_commits,
        programming_languages=programming_languages,
        require_diff=require_diff,
        top_n=top_n,
        output_dir=output_dir,
    )

    # 检查提取的数据是否为空
    if vulnerable_code_df.empty:
        logger.warning("未提取到任何漏洞代码，程序结束")
        return

    # 步骤2: 识别重复模式（使用新的 CWE 基于的方法）
    # 注意：vulnerable_code_df 已经包含了 top n CWE 的数据，所以这里直接使用
    logger.info("\n步骤2: 使用基于 CWE 的模式识别方法")
    logger.info("注意：vulnerable_code_df 已经筛选为 top n CWE 的数据")
    recurring_patterns_df = process_cwe_based_patterns(
        vulnerable_code_df,
        db_connector,
        top_n=top_n,
        min_score=min_score,
        programming_languages=programming_languages,
        output_dir=output_dir,
    )

    if len(recurring_patterns_df) <= 0:
        logger.warning("未找到模式")
        # 即使没有找到模式，也打印统计信息
        logger.info("\n" + "=" * 60)
        logger.info("统计信息:")
        logger.info(f"  总记录数: {len(vulnerable_code_df)}")
        logger.info(f"  唯一 CVE 数: {vulnerable_code_df['cve_id'].nunique()}")
        logger.info(f"  唯一 commit 数: {vulnerable_code_df['hash'].nunique()}")
        logger.info(f"  唯一仓库数: {vulnerable_code_df['repo_url'].nunique()}")
        logger.info(f"  唯一文件数: {vulnerable_code_df['filename'].nunique()}")
        logger.info(f"  识别出的重复模式数: 0")
        logger.info("=" * 60)
        return

    # 步骤3: 生成 GitHub 搜索查询
    logger.info(f"\n步骤3: 为 {len(recurring_patterns_df)} 个模式生成 GitHub 查询")
    query_generator = GitHubQueryGenerator()
    recurring_patterns_df = query_generator.generate_github_search_keywords(
        recurring_patterns_df,
        output_dir=output_dir,
        top_n=top_n,
        save_file=True,
    )

    # 打印统计信息
    logger.info("\n" + "=" * 60)
    logger.info("统计信息:")
    logger.info(f"  总记录数: {len(vulnerable_code_df)}")
    logger.info(f"  唯一 CVE 数: {vulnerable_code_df['cve_id'].nunique()}")
    logger.info(f"  唯一 commit 数: {vulnerable_code_df['hash'].nunique()}")
    logger.info(f"  唯一仓库数: {vulnerable_code_df['repo_url'].nunique()}")
    logger.info(f"  唯一文件数: {vulnerable_code_df['filename'].nunique()}")
    logger.info(f"  识别出的重复模式数: {len(recurring_patterns_df)}")
    if len(recurring_patterns_df) > 0:
        logger.info(f"  生成的 GitHub 查询数: {len(recurring_patterns_df)}")
    logger.info("=" * 60)

    logger.info("\n提取完成！")


def parse_arguments():
    """
    解析命令行参数

    Returns:
        argparse.Namespace: 解析后的命令行参数对象
    """
    parser = argparse.ArgumentParser(description="提取候选重复漏洞代码模式")
    parser.add_argument(
        "--top-n",
        type=int,
        default=3,
        help="返回出现次数最多的前 n 个模式（默认: 3）",
    )
    parser.add_argument(
        "--min-score",
        type=int,
        default=65,
        help="fixes.score 的最小值（默认: 65）",
    )
    parser.add_argument(
        "--include-merge",
        action="store_true",
        help="包含 merge commit（默认: 排除）",
    )
    parser.add_argument(
        "--languages",
        nargs="+",
        default=["java"],  # 可以使用任何大小写形式，如 "java"、"JAVA"、"Java"
        help="编程语言列表，不区分大小写（默认: java）。例如：--languages java 或 --languages Java Go",
    )

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_arguments()

    main(
        top_n=args.top_n,
        min_score=args.min_score,
        exclude_merge_commits=not args.include_merge,
        programming_languages=args.languages,
    )
